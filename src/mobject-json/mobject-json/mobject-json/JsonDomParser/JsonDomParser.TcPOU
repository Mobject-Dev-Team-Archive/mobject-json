<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="JsonDomParser" Id="{9ee703c7-5146-4108-a56a-2e66870e39e2}" SpecialFunc="None">
    <Declaration><![CDATA[{attribute 'no_explicit_call' := 'This FB is a CLASS and must be accessed using methods or properties'}
{attribute 'enable_dynamic_creation'}
FUNCTION_BLOCK JsonDomParser EXTENDS FB_JsonDynDomParser
VAR
	currentlyParsingType : (NOTHING, DOT_NOTATION_PROPERTY, BRACKET_NOTATION_PROPERTY_OR_ARRAY, BRACKET_NOTATION_PROPERTY_ELEMENT, BRACKET_NOTATION_ARRAY_ELEMENT);
	readWriteDataType : FB_JsonReadWriteDataType;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Folder Name="Private" Id="{57ebaeff-72b8-48f1-a518-b5e3240b9107}" />
    <Method Name="ConvertPathToJsonPosition" Id="{91121397-dd47-4729-b855-0f647368f2eb}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PRIVATE ConvertPathToJsonPosition : SJsonValue
VAR_INPUT
	Path : REFERENCE TO STRING;
	Document : SJsonValue;
END_VAR
VAR
//	pRootElement : POINTER TO JsonPathElement_Root;
//	pPropertyElement : POINTER TO JsonPathElement_Property; 
//	pArrayElement : POINTER TO JsonPathElement_ArraySingleSelector; 
	
	currentJsonPosition : SJsonValue;
	currentCharacterPositionInPath : UDINT;

	currentElementStart : UDINT;
	currentElementEnd : UDINT;
	currentElementLength : UDINT;
	elementText : T_MAXSTRING;
	endOfRepeat : BOOL;
END_VAR
VAR CONSTANT
	PERIOD : BYTE := 16#2E; // .
	DOLLAR_SIGN : BYTE := 16#24; // $
	SINGLE_QUOTE : BYTE := 16#27; // '
	LEFT_SQUARE_BRACKET : BYTE := 16#5B; // [
	RIGHT_SQUARE_BRACKET : BYTE := 16#5D; // ]
	NULL : BYTE := 0; // null
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF Path[0] = NULL THEN
	RETURN;
END_IF

currentCharacterPositionInPath := 0;
currentlyParsingType := NOTHING;
currentJsonPosition := Document;

REPEAT 
	
	IF currentJsonPosition = 0 THEN
		RETURN;
	END_IF
	
	IF Path[currentCharacterPositionInPath] = NULL THEN
		 endOfRepeat := TRUE;
	END_IF
		
	CASE currentlyParsingType OF
		
		NOTHING: 
		
			// at this point we are not currently "parsing" a known type from the string, therfore the next character should 
			// decide what type is next. 
		
			IF Path[currentCharacterPositionInPath] = DOLLAR_SIGN THEN
				
				// i.e. the following string $.myValue would indicate that we are here.
				//                           ^                                         
				// as such, we do not need to take any action.  We already create a root element at the start, so this is an 
				// optional character which they do not need to supply. 				
				
			ELSIF Path[currentCharacterPositionInPath] = PERIOD THEN
				
				// i.e. the following string $.myValue would indicate that we are here.
				//                            ^                                        
				// as such, we do not need to take any action.  
				
			ELSIF Path[currentCharacterPositionInPath] = LEFT_SQUARE_BRACKET THEN
				
				// i.e. the following string $.myValue[1].['myProperty'] would indicate that we could be at the start of one of two types
				//                                    ^   ^                                      
				// as such, we mark that we could be either a property or array and continue				
				currentlyParsingType := BRACKET_NOTATION_PROPERTY_OR_ARRAY;				
				
			ELSIF Path[currentCharacterPositionInPath] = RIGHT_SQUARE_BRACKET THEN
				
				// This would indicate a failed parse as this should not happen.
				
			ELSIF Path[currentCharacterPositionInPath] = SINGLE_QUOTE THEN
				
				// This would indicate a failed parse as this should not happen.
				
			ELSE
				
				// i.e. the following string $.myValue[1].['myProperty'] would indicate that we could be at the start of a property
				//                             ^                      
				currentlyParsingType := DOT_NOTATION_PROPERTY;
				currentElementStart := currentCharacterPositionInPath;	
		
			END_IF
			
		DOT_NOTATION_PROPERTY:
		
			IF Path[currentCharacterPositionInPath] = PERIOD OR Path[currentCharacterPositionInPath] = LEFT_SQUARE_BRACKET OR Path[currentCharacterPositionInPath] = NULL THEN
				
				currentElementEnd := currentCharacterPositionInPath - 1;
				
				currentElementLength := 1 + currentElementEnd - currentElementStart;
				memset(ADR(elementText),0,SIZEOF(elementText));
				memcpy(ADR(elementText),ADR(Path[currentElementStart]),currentElementLength);
		
				currentJsonPosition := FindMember(currentJsonPosition,elementText);	
				currentlyParsingType := NOTHING;
				CONTINUE;
				
			END_IF
			
		BRACKET_NOTATION_PROPERTY_OR_ARRAY:
		
			IF Path[currentCharacterPositionInPath] = SINGLE_QUOTE THEN
				currentlyParsingType := BRACKET_NOTATION_PROPERTY_ELEMENT;
				currentElementStart := currentCharacterPositionInPath + 1;			
			ELSE
				currentlyParsingType := BRACKET_NOTATION_ARRAY_ELEMENT;
				currentElementStart := currentCharacterPositionInPath;			
			END_IF
			
		BRACKET_NOTATION_PROPERTY_ELEMENT:
		
			IF Path[currentCharacterPositionInPath] = SINGLE_QUOTE THEN
				
				currentElementEnd := currentCharacterPositionInPath - 1;

				currentElementLength := 1 + currentElementEnd - currentElementStart;
				memset(ADR(elementText),0,SIZEOF(elementText));
				memcpy(ADR(elementText),ADR(Path[currentElementStart]),currentElementLength);
				
				currentJsonPosition := FindMember(currentJsonPosition,elementText);				
				currentlyParsingType := NOTHING;
						
			END_IF
			
		BRACKET_NOTATION_ARRAY_ELEMENT:
		
			IF Path[currentCharacterPositionInPath] = RIGHT_SQUARE_BRACKET THEN
				
				currentElementEnd := currentCharacterPositionInPath - 1;
				
				currentElementLength := 1 + currentElementEnd - currentElementStart;
				memset(ADR(elementText),0,SIZEOF(elementText));
				memcpy(ADR(elementText),ADR(Path[currentElementStart]),currentElementLength);
				
				currentJsonPosition := GetArrayValueByIdx(currentJsonPosition, STRING_TO_UDINT(elementText));		
				currentlyParsingType := NOTHING;
						
			END_IF
			

	END_CASE
	
	currentCharacterPositionInPath := currentCharacterPositionInPath + 1;
	
UNTIL endOfRepeat 
END_REPEAT
	
ConvertPathToJsonPosition := currentJsonPosition;]]></ST>
      </Implementation>
    </Method>
    <Method Name="TryModify" Id="{6e1a9e09-ed83-492b-82c6-fce6ce715223}">
      <Declaration><![CDATA[METHOD PUBLIC TryModify : BOOL
VAR_INPUT
	Path : T_MaxString;
	Source : ANY;
END_VAR
VAR
	root : SJsonValue;
	jsonValue : SJsonValue;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[root := GetDocumentRoot();
jsonValue := ConvertPathToJsonPosition(Path, root);

IF jsonValue = 0 THEN
	RETURN;
END_IF

IF IsArray(jsonValue) OR IsObject(jsonValue) THEN
	RETURN;
END_IF

IF TrySetBool(jsonValue, Source) THEN
	TryModify := TRUE;
	RETURN;
END_IF

IF TrySetString(jsonValue, Source) THEN
	TryModify := TRUE;
	RETURN;
END_IF

IF TrySetInt(jsonValue, Source) THEN
	TryModify := TRUE;
	RETURN;
END_IF

IF TrySetUint(jsonValue, Source) THEN
	TryModify := TRUE;
	RETURN;
END_IF

IF TrySetDouble(jsonValue, Source) THEN
	TryModify := TRUE;
	RETURN;
END_IF

IF TrySetInt64(jsonValue, Source) THEN
	TryModify := TRUE;
	RETURN;
END_IF

IF TrySetUint64(jsonValue, Source) THEN
	TryModify := TRUE;
	RETURN;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="TryRead" Id="{234502bb-5c8e-4971-9b37-2729581facef}">
      <Declaration><![CDATA[METHOD PUBLIC TryRead : BOOL
VAR_INPUT
	Path : T_MaxString;
	Destination : ANY;
END_VAR
VAR
	root : SJsonValue;
	jsonValue : SJsonValue;
	_BOOL : BOOL;
	_DINT : DINT;
	_LINT : LINT;
	_UDINT : UDINT;
	_ULINT : ULINT;
	_LREAL : LREAL;
	_STRING : POINTER TO STRING(1);
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[root := GetDocumentRoot();
jsonValue := ConvertPathToJsonPosition(Path, root);

IF jsonValue = 0 THEN
	RETURN;
END_IF

IF IsBool(jsonValue) THEN
	_BOOL := GetBool(jsonValue);
	TryRead := TryConvert_BOOL_TO_DESTINATION(_BOOL,Destination);
	RETURN;
END_IF

IF IsInt(jsonValue) THEN
	_DINT := GetInt(jsonValue);
	TryRead := TryConvert_DINT_TO_DESTINATION(_DINT,Destination);
	RETURN;
END_IF

IF IsInt64(jsonValue) THEN
	_LINT := GetInt64(jsonValue);
	TryRead := TryConvert_LINT_TO_DESTINATION(_LINT,Destination);
	RETURN;
END_IF

IF IsUInt(jsonValue) THEN
	_UDINT := GetUInt(jsonValue);
	TryRead := TryConvert_UDINT_TO_DESTINATION(_UDINT,Destination);
	RETURN;
END_IF

IF IsUInt64(jsonValue) THEN
	_ULINT := GetUInt64(jsonValue);
	TryRead := TryConvert_ULINT_TO_DESTINATION(_ULINT,Destination);
	RETURN;
END_IF

IF IsDouble(jsonValue) THEN
	_LREAL := GetDouble(jsonValue);
	TryRead := TryConvert_LREAL_TO_DESTINATION(_LREAL,Destination);
	RETURN;
END_IF

IF IsString(jsonValue) AND Destination.TypeClass = __SYSTEM.TYPE_CLASS.TYPE_STRING THEN
	_STRING := Destination.pValue;
	IF (CopyString(jsonValue,_STRING^,Destination.diSize) > 0) THEN;
		TryRead := TRUE;
		RETURN;
	END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="TrySetBool" Id="{8fb294b9-07c6-4ca3-b8ac-1e2052c9956f}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PRIVATE TrySetBool : BOOL
VAR_INPUT
	JsonValue : SJsonValue;
	Source : ANY;
END_VAR
VAR
	_BOOL : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF Source.TypeClass <> __SYSTEM.TYPE_CLASS.TYPE_BOOL THEN	
	RETURN;
END_IF

memcpy(ADR(_BOOL),Source.pValue,Source.diSize);
SetBool(jsonValue,_BOOL);
TrySetBool := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="TrySetDouble" Id="{0cad1601-2c3a-4991-bd69-b39816b16beb}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PRIVATE TrySetDouble : BOOL
VAR_INPUT
	JsonValue : SJsonValue;
	Source : ANY;
END_VAR
VAR
	convertSuccessful : BOOL;
	_REAL : REAL;
	_LREAL : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE Source.TypeClass OF 

	__SYSTEM.TYPE_CLASS.TYPE_REAL : 
		memcpy(ADR(_REAL),Source.pValue,Source.diSize);
		convertSuccessful := TryConvert_Source_TO_Destination(_REAL,_LREAL);
	
	__SYSTEM.TYPE_CLASS.TYPE_LREAL : 
		memcpy(ADR(_LREAL),Source.pValue,Source.diSize);
		convertSuccessful := TRUE;
		
ELSE 
		
	RETURN;
		
END_CASE

IF NOT convertSuccessful THEN
	RETURN;
END_IF

SetDouble(jsonValue,_LREAL);
TrySetDouble := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="TrySetInt" Id="{a4dab10e-f4b2-451d-bb8a-494af1c3dad6}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PRIVATE TrySetInt : BOOL
VAR_INPUT
	JsonValue : SJsonValue;
	Source : ANY;
END_VAR
VAR
	convertSuccessful : BOOL;
	_SINT : USINT;	
	_INT : UINT;
	_DINT : UDINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE Source.TypeClass OF
		
	__SYSTEM.TYPE_CLASS.TYPE_SINT : 
		memcpy(ADR(_SINT),Source.pValue,Source.diSize);
		convertSuccessful := TryConvert_Source_TO_Destination(_SINT,_DINT);
		
	__SYSTEM.TYPE_CLASS.TYPE_INT : 
		memcpy(ADR(_INT),Source.pValue,Source.diSize);
		convertSuccessful := TryConvert_Source_TO_Destination(_INT,_DINT);
		
	__SYSTEM.TYPE_CLASS.TYPE_DINT : 
		memcpy(ADR(_DINT),Source.pValue,Source.diSize);
		convertSuccessful := TRUE;
		
ELSE 
		
	RETURN;
		
END_CASE

IF NOT convertSuccessful THEN
	RETURN;
END_IF

SetInt(jsonValue,_DINT); // Not a typo, SetInt actually takes a DINT
TrySetInt := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="TrySetInt64" Id="{e4eb315c-13d4-488b-862d-e7e83993ab9d}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PRIVATE TrySetInt64 : BOOL
VAR_INPUT
	JsonValue : SJsonValue;
	Source : ANY;
END_VAR
VAR
	_LINT : LINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF Source.TypeClass <> __SYSTEM.TYPE_CLASS.TYPE_LINT THEN	
	RETURN;
END_IF

memcpy(ADR(_LINT),Source.pValue,Source.diSize);
SetInt64(jsonValue,_LINT);
TrySetInt64 := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="TrySetString" Id="{9205d3e3-7854-41cd-b721-995a1b6efb27}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PRIVATE TrySetString : BOOL
VAR_INPUT
	JsonValue : SJsonValue;
	Source : ANY;
END_VAR
VAR
	_STRING : POINTER TO STRING(1);
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF Source.TypeClass <> __SYSTEM.TYPE_CLASS.TYPE_STRING THEN	
	RETURN;
END_IF

_STRING := Source.pValue;

SetString(jsonValue,_STRING^);
TrySetString := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="TrySetUint" Id="{8c571182-400a-42cc-85f8-a7567a4a34e9}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PRIVATE TrySetUint : BOOL
VAR_INPUT
	JsonValue : SJsonValue;
	Source : ANY;
END_VAR
VAR
	convertSuccessful : BOOL;
	_BYTE : BYTE;
	_WORD : WORD;
	_DWORD : DWORD;	
	_USINT : USINT;	
	_UINT : UINT;
	_UDINT : UDINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE Source.TypeClass OF 

	__SYSTEM.TYPE_CLASS.TYPE_BYTE : 
		memcpy(ADR(_BYTE),Source.pValue,Source.diSize);
		convertSuccessful := TryConvert_Source_TO_Destination(_BYTE,_UDINT);
	
	__SYSTEM.TYPE_CLASS.TYPE_WORD : 
		memcpy(ADR(_WORD),Source.pValue,Source.diSize);
		convertSuccessful := TryConvert_Source_TO_Destination(_WORD,_UDINT);
		
	__SYSTEM.TYPE_CLASS.TYPE_DWORD : 
		memcpy(ADR(_DWORD),Source.pValue,Source.diSize);
		convertSuccessful := TryConvert_Source_TO_Destination(_DWORD,_UDINT);
		
	__SYSTEM.TYPE_CLASS.TYPE_USINT : 
		memcpy(ADR(_USINT),Source.pValue,Source.diSize);
		convertSuccessful := TryConvert_Source_TO_Destination(_USINT,_UDINT);
		
	__SYSTEM.TYPE_CLASS.TYPE_UINT : 
		memcpy(ADR(_UINT),Source.pValue,Source.diSize);
		convertSuccessful := TryConvert_Source_TO_Destination(_UINT,_UDINT);
		
	__SYSTEM.TYPE_CLASS.TYPE_UDINT : 
		memcpy(ADR(_UDINT),Source.pValue,Source.diSize);
		convertSuccessful := TRUE;
		
ELSE 
		
	RETURN;
		
END_CASE

IF NOT convertSuccessful THEN
	RETURN;
END_IF

SetUint(jsonValue,_UDINT); // Not a typo, SetUnit actually takes a UDINT
TrySetUint := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="TrySetUint64" Id="{c9a8c18d-4cf6-42df-9701-a9243833dd8f}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PRIVATE TrySetUint64 : BOOL
VAR_INPUT
	JsonValue : SJsonValue;
	Source : ANY;
END_VAR
VAR
	convertSuccessful : BOOL;
	_LWORD : LWORD;
	_ULINT : LINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE Source.TypeClass OF 

	__SYSTEM.TYPE_CLASS.TYPE_LWORD : 
		memcpy(ADR(_LWORD),Source.pValue,Source.diSize);
		convertSuccessful := TryConvert_Source_TO_Destination(_LWORD,_ULINT);
	
	__SYSTEM.TYPE_CLASS.TYPE_ULINT : 
		memcpy(ADR(_ULINT),Source.pValue,Source.diSize);
		convertSuccessful := TRUE;
		
ELSE 
		
	RETURN;
		
END_CASE

IF NOT convertSuccessful THEN
	RETURN;
END_IF

SetUint64(jsonValue,_ULINT);
TrySetUint64 := TRUE;]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="JsonDomParser">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="JsonDomParser.ConvertPathToJsonPosition">
      <LineId Id="3" Count="125" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="JsonDomParser.TryModify">
      <LineId Id="217" Count="43" />
      <LineId Id="194" Count="0" />
    </LineIds>
    <LineIds Name="JsonDomParser.TryRead">
      <LineId Id="3" Count="48" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="JsonDomParser.TrySetBool">
      <LineId Id="121" Count="0" />
      <LineId Id="125" Count="0" />
      <LineId Id="123" Count="0" />
      <LineId Id="127" Count="0" />
      <LineId Id="126" Count="0" />
      <LineId Id="129" Count="0" />
      <LineId Id="128" Count="0" />
    </LineIds>
    <LineIds Name="JsonDomParser.TrySetDouble">
      <LineId Id="32" Count="0" />
      <LineId Id="42" Count="0" />
      <LineId Id="41" Count="0" />
      <LineId Id="33" Count="1" />
      <LineId Id="78" Count="0" />
      <LineId Id="58" Count="1" />
      <LineId Id="57" Count="0" />
      <LineId Id="73" Count="0" />
      <LineId Id="45" Count="0" />
      <LineId Id="81" Count="0" />
      <LineId Id="47" Count="0" />
      <LineId Id="82" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="49" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="50" Count="2" />
      <LineId Id="40" Count="0" />
      <LineId Id="54" Count="0" />
    </LineIds>
    <LineIds Name="JsonDomParser.TrySetInt">
      <LineId Id="32" Count="0" />
      <LineId Id="76" Count="0" />
      <LineId Id="65" Count="1" />
      <LineId Id="64" Count="0" />
      <LineId Id="75" Count="0" />
      <LineId Id="68" Count="1" />
      <LineId Id="67" Count="0" />
      <LineId Id="74" Count="0" />
      <LineId Id="71" Count="1" />
      <LineId Id="70" Count="0" />
      <LineId Id="73" Count="0" />
      <LineId Id="45" Count="0" />
      <LineId Id="81" Count="0" />
      <LineId Id="47" Count="0" />
      <LineId Id="82" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="49" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="50" Count="2" />
      <LineId Id="40" Count="0" />
      <LineId Id="54" Count="0" />
    </LineIds>
    <LineIds Name="JsonDomParser.TrySetInt64">
      <LineId Id="121" Count="0" />
      <LineId Id="125" Count="0" />
      <LineId Id="123" Count="0" />
      <LineId Id="127" Count="0" />
      <LineId Id="126" Count="0" />
      <LineId Id="129" Count="0" />
      <LineId Id="128" Count="0" />
    </LineIds>
    <LineIds Name="JsonDomParser.TrySetString">
      <LineId Id="121" Count="0" />
      <LineId Id="125" Count="0" />
      <LineId Id="123" Count="0" />
      <LineId Id="127" Count="0" />
      <LineId Id="126" Count="0" />
      <LineId Id="149" Count="0" />
      <LineId Id="148" Count="0" />
      <LineId Id="137" Count="0" />
    </LineIds>
    <LineIds Name="JsonDomParser.TrySetUint">
      <LineId Id="32" Count="0" />
      <LineId Id="42" Count="0" />
      <LineId Id="41" Count="0" />
      <LineId Id="33" Count="1" />
      <LineId Id="78" Count="0" />
      <LineId Id="58" Count="1" />
      <LineId Id="57" Count="0" />
      <LineId Id="77" Count="0" />
      <LineId Id="62" Count="1" />
      <LineId Id="61" Count="0" />
      <LineId Id="76" Count="0" />
      <LineId Id="65" Count="1" />
      <LineId Id="64" Count="0" />
      <LineId Id="75" Count="0" />
      <LineId Id="68" Count="1" />
      <LineId Id="67" Count="0" />
      <LineId Id="74" Count="0" />
      <LineId Id="71" Count="1" />
      <LineId Id="70" Count="0" />
      <LineId Id="73" Count="0" />
      <LineId Id="45" Count="0" />
      <LineId Id="81" Count="0" />
      <LineId Id="47" Count="0" />
      <LineId Id="82" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="49" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="50" Count="2" />
      <LineId Id="40" Count="0" />
      <LineId Id="54" Count="0" />
    </LineIds>
    <LineIds Name="JsonDomParser.TrySetUint64">
      <LineId Id="144" Count="20" />
      <LineId Id="128" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>